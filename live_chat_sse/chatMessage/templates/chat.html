<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat Dynamique</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: flex-end; /* Pour aligner le bouton √† droite */
            align-items: flex-end; /* Pour aligner le bouton en bas */
            min-height: 100vh; /* Prend toute la hauteur de la fen√™tre */
            background-color: #f0f2f5;
        }

        /* Bouton pour ouvrir le chat */
        .open-chat-button {
            position: fixed; /* Fix√© par rapport √† la fen√™tre */
            bottom: 20px;
            right: 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            font-size: 30px;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 1000; /* Assure qu'il est au-dessus des autres √©l√©ments */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Styles de la bulle de chat */
        .chat-bubble {
            width: 350px;
            height: 450px;
            background-color: #ffffff;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            display: none; /* Cach√© par d√©faut, sera contr√¥l√© par JS */
            flex-direction: column;
            position: fixed; /* Fix√© par rapport √† la fen√™tre */
            bottom: 90px; /* Au-dessus du bouton d'ouverture */
            right: 20px;
            z-index: 999;
            overflow: hidden; /* Pour que les bords arrondis s'appliquent au contenu */
        }

        .chat-header {
            background-color: #007bff;
            color: white;
            padding: 15px;
            border-top-left-radius: 10px;
            border-top-right-radius: 10px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer; /* Pour indiquer qu'on peut cliquer pour basculer */
            text-align: center;
        }

        .chat-body {
            flex-grow: 1;
            padding: 15px;
            overflow-y: auto; /* Permet le d√©filement des messages */
            border-bottom: 1px solid #eee;
            background-color: #f9f9f9;
            display: flex; /* Utilise flexbox pour empiler les messages */
            flex-direction: column;
        }

        .chat-message {
            margin-bottom: 10px;
            padding: 8px 12px;
            border-radius: 15px;
            max-width: 80%;
            word-wrap: break-word; /* Casse les mots longs */
            line-height: 1.4;
            /* Ajout pour un positionnement correct dans flex-direction: column */
            align-self: flex-start;
        }

        .chat-message.self {
            background-color: #dcf8c6; /* Vert clair pour ses propres messages */
            align-self: flex-end;
            margin-left: auto;
        }

        .chat-message.other {
            background-color: #e2e2e2; /* Gris clair pour les messages des autres */
            align-self: flex-start;
            margin-right: auto;
        }

        .message-sender {
            font-weight: bold;
            margin-bottom: 3px;
            display: block; /* Pour que le nom soit sur sa propre ligne */
        }

        .message-timestamp {
            font-size: 0.75em;
            color: #888;
            margin-top: 3px;
            display: block; /* Pour que le timestamp soit sur sa propre ligne */
            text-align: right;
        }

        .chat-input {
            padding: 10px 15px;
            border-top: 1px solid #eee;
            display: flex;
            flex-direction: column; /* Inputs empil√©s */
            gap: 5px; /* Espace entre les inputs */
        }

        .chat-input input[type="text"],
        .chat-input button {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 0.9em;
        }

        .chat-input input[type="text"] {
            width: calc(100% - 22px); /* Moins le padding et bordures */
        }

        .chat-input button {
            background-color: #28a745;
            color: white;
            cursor: pointer;
            border: none;
            transition: background-color 0.2s;
            width: 100%;
            box-sizing: border-box; /* Inclut padding et border dans la largeur */
        }

        .chat-input button:hover {
            background-color: #218838;
        }

        /* Styles sp√©cifiques pour les chats priv√©s */
        .private-chat {
            right: 390px; /* D√©cale les chats priv√©s √† gauche pour ne pas chevaucher le chat g√©n√©ral */
            width: 350px;
            height: 450px;
        }

        .private-chat .chat-header {
            background-color: #6c757d; /* Couleur diff√©rente pour le header des priv√©s */
        }

        .private-chat .chat-input button {
            background-color: #17a2b8; /* Couleur diff√©rente pour le bouton des priv√©s */
        }

        .private-chat .chat-input button:hover {
            background-color: #138496;
        }

    </style>
</head>
<body>

    <button class="open-chat-button" onclick="toggleChat('general', true)">üí¨</button>

    <script>
        const chatBubbles = {}; // Stocke les r√©f√©rences aux √©l√©ments de bulle par groupName
        const eventSources = {}; // Stocke les objets EventSource par groupName
        const messageOffsets = {}; // NOUVEAU: Stocke l'offset pour l'historique de chaque groupe

        // Helper pour cr√©er un √©l√©ment message HTML
        function createMessageElement(messageData, groupName) {
			const msg = document.createElement('div');
			msg.classList.add('chat-message');

			const usernameInput = document.getElementById(`usernameInput-${groupName}`);
			const currentUsername = usernameInput ? usernameInput.value : '';

			// D√©termine si c'est son propre message
    	if (messageData.sender === currentUsername || messageData.sender__username === currentUsername) { // Ajout de sender__username pour la compatibilit√© historique
        	msg.classList.add('self');
    	} else {
    	    msg.classList.add('other');
    	}

    	const senderSpan = document.createElement('span');
    	senderSpan.classList.add('message-sender');
    	// UTILISE 'messageData.sender__username' QUI VIENT DE L'HISTORIQUE OU 'messageData.sender' DES NOUVEAUX MESSAGES
    	senderSpan.textContent = messageData.sender__username || messageData.sender;
    	// ... (Reste du code pour le nom d'utilisateur cliquable) ...
    	// Rendre le nom cliquable pour initier un chat priv√© (sauf avec soi-m√™me)
    	const displayedSender = messageData.sender__username || messageData.sender;
    	if (displayedSender && displayedSender !== currentUsername) {
    	    senderSpan.style.cursor = 'pointer';
    	    senderSpan.style.textDecoration = 'underline';
    	    senderSpan.onclick = () => promptPrivateChat(displayedSender, messageData.sender_id || null);
    	}
    	msg.appendChild(senderSpan);

    	const contentText = document.createTextNode(messageData.content);
    	msg.appendChild(contentText);

    	const timestampSpan = document.createElement('span');
    	timestampSpan.classList.add('message-timestamp');
    	timestampSpan.textContent = messageData.timestamp;
    	msg.appendChild(timestampSpan);

    	return msg;
	}

        // NOUVELLE FONCTION: Charger l'historique des messages
        async function loadMessageHistory(groupName, prepend = false) {
            const chatLog = document.getElementById(`chatLog-${groupName}`);
            if (!chatLog) {
                console.error(`chatLog-${groupName} introuvable pour charger l'historique.`);
                return;
            }

            const offset = messageOffsets[groupName] || 0;
            const limit = 20; // Nombre de messages √† charger √† chaque fois

            try {
                const response = await fetch(`/chat/history/${groupName}/?offset=${offset}&limit=${limit}`);
                const data = await response.json();

                if (response.ok && data.status === "success") {
                    if (data.messages.length > 0) {
                        const fragment = document.createDocumentFragment();
                        data.messages.forEach(msgData => {
                            const msgElement = createMessageElement(msgData, groupName);
                            if (prepend) {
                                fragment.appendChild(msgElement);
                            } else {
                                chatLog.appendChild(msgElement);
                            }
                        });

                        if (prepend) {
                            // Si on ajoute en haut, il faut ins√©rer au d√©but et ajuster le scroll
                            const oldScrollHeight = chatLog.scrollHeight;
                            chatLog.insertBefore(fragment, chatLog.firstChild);
                            const newScrollHeight = chatLog.scrollHeight;
                            // Maintenir la position de d√©filement relative
                            chatLog.scrollTop = newScrollHeight - oldScrollHeight;
                        } else {
                            chatLog.appendChild(fragment);
                            chatLog.scrollTop = chatLog.scrollHeight; // D√©filer vers le bas apr√®s chargement initial
                        }
                        messageOffsets[groupName] = offset + data.messages.length;
                    } else if (!prepend) {
                        // Si aucun message n'est charg√© au d√©but, c'est peut-√™tre la premi√®re fois
                        console.log(`Pas d'historique pour ${groupName} ou fin de l'historique.`);
                    }
                } else {
                    console.error("Erreur de chargement historique:", data.message || "Unknown error");
                }
            } catch (error) {
                console.error("Erreur r√©seau lors du chargement de l'historique:", error);
            }
        }

        // Fonction pour cr√©er une bulle de chat dynamique
        async function createChatBubble(groupName, isPrivate = false) {
            // Si la bulle existe d√©j√†, l'afficher et ne pas la recr√©er
            if (chatBubbles[groupName]) {
                toggleChat(groupName, true); // Force l'affichage
                // S'assurer que le nom d'utilisateur est copi√© si c'est un nouveau chat priv√©
                const usernameInputGeneral = document.getElementById('usernameInput-general');
                const usernameInputCurrent = document.getElementById(`usernameInput-${groupName}`);
                if (usernameInputGeneral && usernameInputCurrent && !usernameInputCurrent.value) {
                    usernameInputCurrent.value = usernameInputGeneral.value;
                }
                const chatLog = document.getElementById(`chatLog-${groupName}`);
                if (chatLog) {
                    chatLog.scrollTop = chatLog.scrollHeight; // Scroll vers le bas
                }
                return;
            }

            const chatContainer = document.createElement('div');
            chatContainer.classList.add('chat-bubble');
            chatContainer.id = `chatBubble-${groupName}`;

            if (isPrivate) {
                chatContainer.classList.add('private-chat');
            }

            // G√©n√©rer le contenu HTML de la bulle en utilisant les IDs dynamiques
            chatContainer.innerHTML = `
                <div class="chat-header" onclick="toggleChat('${groupName}')">
                    ${isPrivate ? `Chat Priv√© (${groupName.split('_').slice(1).join(' - ')})` : 'Chat G√©n√©ral'}
                </div>
                <div class="chat-body" id="chatLog-${groupName}">
                    </div>
                <div class="chat-input">
                    <input type="text" id="usernameInput-${groupName}" placeholder="Votre nom">
                    <input type="hidden" id="groupNameInput-${groupName}" value="${groupName}">
                </div>
                <div class="chat-input">
                    <input type="text" id="messageInput-${groupName}" placeholder="√âcris un message">
                    <button onclick="sendMessage('${groupName}')">Envoyer</button>
                </div>
            `;

            document.body.appendChild(chatContainer); // Ajouter la bulle au corps du document
            chatBubbles[groupName] = chatContainer; // Stocker la r√©f√©rence

            toggleChat(groupName, true); // Afficher la nouvelle bulle

            // Copier le nom d'utilisateur si d√©j√† renseign√© dans le chat g√©n√©ral
            const usernameInputGeneral = document.getElementById('usernameInput-general');
            const usernameInputCurrent = document.getElementById(`usernameInput-${groupName}`);
            if (usernameInputGeneral && usernameInputCurrent) {
                usernameInputCurrent.value = usernameInputGeneral.value;
            }

            // NOUVEAU: Charger l'historique des messages pour cette bulle
            await loadMessageHistory(groupName);

            // Initialiser la connexion SSE pour ce nouveau groupe apr√®s avoir charg√© l'historique
            initEventSource(groupName);

            // NOUVEAU: Ajouter l'√©couteur de scroll pour charger plus d'historique
            const chatLog = document.getElementById(`chatLog-${groupName}`);
            if (chatLog) {
                chatLog.addEventListener('scroll', function() {
                    // Si l'utilisateur a scroll√© tout en haut
                    if (chatLog.scrollTop === 0) {
                        loadMessageHistory(groupName, true); // Charger plus d'historique et l'ajouter en haut
                    }
                });
            }
        }

        // Fonction pour afficher/masquer une bulle de chat
        function toggleChat(groupName, forceDisplay = false) {
            const bubble = document.getElementById(`chatBubble-${groupName}`);
            if (bubble) {
                if (forceDisplay) {
                    bubble.style.display = 'flex';
                } else {
                    bubble.style.display = (bubble.style.display === 'none' || bubble.style.display === '') ? 'flex' : 'none';
                }
                // Si affich√©, faire d√©filer vers le bas
                if (bubble.style.display === 'flex') {
                    const chatLog = document.getElementById(`chatLog-${groupName}`);
                    if (chatLog) {
                        chatLog.scrollTop = chatLog.scrollHeight;
                    }
                    // NOUVEAU: retirer le point rouge si la bulle est ouverte (futur)
                    // removeNotificationDot(groupName);
                }
            }
        }

        // Fonction pour envoyer un message
        async function sendMessage(groupName) {
            const usernameInput = document.getElementById(`usernameInput-${groupName}`);
            const messageInput = document.getElementById(`messageInput-${groupName}`);
            const groupNameInput = document.getElementById(`groupNameInput-${groupName}`);

            const username = usernameInput.value.trim();
            const content = messageInput.value.trim();
            const currentGroupName = groupNameInput.value;

            if (!username || !content) {
                alert("Veuillez entrer votre nom et un message.");
                return;
            }

            try {
                const response = await fetch("/chat/send/", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "X-CSRFToken": getCookie('csrftoken')
                    },
                    body: JSON.stringify({
                        username: username,
                        content: content,
                        group_name: currentGroupName
                    }),
                });

                const data = await response.json();
                if (response.ok) {
                    if (data.status === "success") {
                        messageInput.value = "";
                    } else {
                        console.error("Erreur serveur lors de l'envoi:", data.message);
                        alert("Erreur lors de l'envoi du message: " + data.message);
                    }
                } else {
                    console.error("Erreur HTTP lors de l'envoi:", response.status, data.message || response.statusText);
                    alert("Erreur HTTP: " + (data.message || response.statusText));
                }
            } catch (error) {
                console.error("Erreur r√©seau ou JSON:", error);
                alert("Impossible de se connecter au serveur pour envoyer le message.");
            }
        }

        // Fonction pour initialiser l'EventSource (SSE) pour un groupe
        function initEventSource(groupName) {
            if (eventSources[groupName] && eventSources[groupName].readyState === EventSource.OPEN) {
                return;
            }

            const chatLog = document.getElementById(`chatLog-${groupName}`);
            if (!chatLog) {
                console.error(`chatLog-${groupName} introuvable pour initEventSource.`);
                return;
            }

            const source = new EventSource(`/chat/stream/${groupName}/`);
            eventSources[groupName] = source;

            source.onmessage = function(e) {
                try {
                    // Les messages SSE sont envoy√©s directement par le backend en JSON pour le stream
                    const messageData = JSON.parse(e.data);
                    const msgElement = createMessageElement(messageData, groupName);
                    chatLog.appendChild(msgElement);
                    chatLog.scrollTop = chatLog.scrollHeight; // D√©filer vers le bas
                    // NOUVEAU: Ajouter le point rouge si la bulle n'est pas visible (futur)
                    // addNotificationDot(groupName);
                } catch (error) {
                    console.error("Erreur de parsing JSON ou de traitement du message SSE:", error, e.data);
                }
            };

            source.onerror = function(err) {
                console.error("EventSource failed:", err);
                // G√©rer les erreurs de connexion SSE (reconnexion, affichage message utilisateur, etc.)
                // source.close(); // Peut-√™tre fermer et tenter de reconnecter apr√®s un d√©lai
            };
        }

        // Fonction pour obtenir le token CSRF (inchang√©e)
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }

        // Fonction pour demander la cr√©ation/r√©cup√©ration d'un groupe priv√© (inchang√©e)
        async function promptPrivateChat(targetUsername, targetUserId) {
            const currentUsernameInput = document.getElementById('usernameInput-general') || document.querySelector('.chat-bubble input[id^="usernameInput-"]');
            if (!currentUsernameInput || !currentUsernameInput.value) {
                alert("Veuillez d'abord entrer votre nom d'utilisateur dans le chat g√©n√©ral.");
                return;
            }
            const currentUsername = currentUsernameInput.value.trim();

            if (currentUsername === targetUsername) {
                alert("Vous ne pouvez pas d√©marrer un chat priv√© avec vous-m√™me.");
                return;
            }

            if (confirm(`Voulez-vous d√©marrer un chat priv√© avec ${targetUsername}?`)) {
                try {
                    const response = await fetch("/chat/create_private_group/", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/x-www-form-urlencoded",
                            "X-CSRFToken": getCookie('csrftoken')
                        },
                        body: new URLSearchParams({
                            current_username: currentUsername,
                            target_username: targetUsername
                            // target_user_id: targetUserId // Si vous avez l'ID et que le backend l'utilise
                        }).toString(),
                    });

                    const data = await response.json();
                    if (response.ok) {
                        if (data.status === "success" && data.group_name) {
                            createChatBubble(data.group_name, true); // Cr√©er la bulle du chat priv√©
                        } else {
                            console.error("Erreur serveur lors de la cr√©ation du groupe priv√©:", data.message);
                            alert("Erreur lors de la cr√©ation du groupe priv√©: " + data.message);
                        }
                    } else {
                        console.error("Erreur HTTP lors de la cr√©ation du groupe priv√©:", response.status, data.error || response.statusText);
                        alert("Erreur HTTP: " + (data.error || response.statusText));
                    }
                } catch (error) {
                    console.error("Erreur r√©seau lors de la cr√©ation du groupe priv√©:", error);
                    alert("Impossible de se connecter au serveur pour cr√©er le groupe priv√©.");
                }
            }
        }


        // Ex√©cute ce code lorsque le DOM est enti√®rement charg√©
        document.addEventListener("DOMContentLoaded", () => {
            // Cr√©er la bulle de chat g√©n√©rale au chargement de la page
            createChatBubble('general', false);

            // Attacher l'√©couteur d'√©v√©nements pour la touche 'Entr√©e'
            document.addEventListener('keydown', function(event) {
                if (event.key === 'Enter') {
                    const activeElement = document.activeElement;
                    if (activeElement && activeElement.id.startsWith('messageInput-')) {
                        const groupName = activeElement.id.split('-')[1];
                        sendMessage(groupName);
                        event.preventDefault();
                    }
                }
            });
        });
    </script>
</body>
</html>
